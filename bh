#!/bin/bash

shopt -s globstar
shopt -s nullglob

# Setup $BIBBASE
function cdtobaseorroot {
	while [ ! -f "$PWD"/.bibbase -a "$PWD" != "/" ] ; do
		cd ..
	done
}

pushd "$PWD" > /dev/null
cdtobaseorroot
if [[ "$PWD" == "/" ]]; then
	if [ -f "/.bibbase" ]; then
		BIBBASE="/"   # But seriously, don't do this.
	elif [ -z "$BIBBASE" ]; then
		echo "\$BIBBASE unset and no database in path"
		exit 1
	elif [ ! -f "${BIBBASE}/.bibbase" ]; then
		echo "$BIBBASE is not a database"
		exit 1
	fi
else
	BIBBASE="$PWD"
fi
popd > /dev/null

function isEntry {
	[ -d "$1" ] && [ -f "$1/.entry" ] && [[ "$1" == "${BIBBASE}/"* ]]
}


# What about NUL?? Seems to break things in BASH.
# _ -> \x5f
# \ -> \x5c
# / -> \x2f
# % -> \x25
# A minimal set.  Printf will consume all \ and %, / disallowed by filesystem
# and we want to avoid the final \'s in the filenames

function encodestring {
	result="$1"
	result="${result//_/_x5f}"
	result="${result//\\/_x5c}"
	result="${result//\//_x2f}"
	result="${result//%/_x25}"
#	result="${result//./_x2e}"
}

function decodestring {
	result="$1"
#	result="${result//_x2e/.}"
	result="${result//_x25/%}"
	result="${result//_x2f/\/}"
	result="${result//_x5f/_}"
	result="${result//_x5c/\\}"
}

declare -a ENTRIES
function entriesorpwd {
	if [ "$#" -eq 0 ]
	then
		ENTRIES[0]=$PWD
	else
		ENTRIES=("$@")
	fi
}

function getentry {
	declare testpath=${1%.entry}
	isEntry "$testpath" || return 1

	declare -a array
	
	pushd "$testpath" > /dev/null
	while [ "$PWD" != "$BIBBASE" ]; do
		array=("${PWD##*/}" "${array[@]}" )
		cd ..
	done
	popd > /dev/null

	IFS="" rawstring="${array[0]}:${array[*]:1}"
	decodestring "$rawstring"
}

function printentry {
	for i in "$@"
	do	
		if getentry "$i"; then
			echo "$result"	
		else
			echo "Not an entry"
		fi
	done
}

#convert string to path
#special handling of "." and ".."  They are disallowed as divisions!
#returned variables:
#	$result: path relative to $BIBBASE
function getpath {
	# String must contain a : to separate the prefix from suffix
	if [[ "$1" != *":"* ]] ; then
		return 1
	fi

	encodestring "${1#*:}"
	declare suffix="$result"
	suffix="${suffix,,}" # to lowercase
	result="${1%%:*}" # Populate result with prefix
	result="${result,,}" # to lowercase

	# Root type _must_ exist
	if [ ! -d "$BIBBASE/$result" ]; then
		unset result
		return 2
	fi

	declare st=0 j=0 t
	
	pushd $BIBBASE > /dev/null
	#for (( j=1, st=0 ; j <= ${#suffix} ; j=j+1 )); do
	while [ $j -le ${#suffix} ]; do
		j=$((j+1))
		app="${suffix:$st:$j-$st}"
		if [ "$app" == "." -o "$app" == ".." ]; then
			continue
		fi
		t="$result/$app"
		if [ -d "$t" ] && [ ! -f "$t"/.entry ]; then
			result=$t
			st=$j
		fi
	done
	popd > /dev/null
	result=$t
}

function printpath {
	local i
	while
		i="$1"
		shift
	do
		getpath "$i" || {
			echo "${FUNCNAME[0]} Bad string ($?): $i"
			continue
		}
		fullpath="$BIBBASE/$result"
		if isEntry "$fullpath"; then
			echo "$fullpath"
		else
			echo "Not an entry: $fullpath"
		fi
	done
}

function enc {
	encodestring "$1"
	echo "$result"
}

# returns $result array of successfully added entries
function add {
	local -a added=()
	local i
	while
		i="$1"
		shift
	do
		getpath "$i" || {
			echo "${FUNCNAME[0]} Bad string ($?): $i. Skipping."
			continue
		}
		d="$BIBBASE/$result"
		[ -d "$d" ] && {
			echo "${FUNCNAME[0]} Entry exists: $d. Skipping."
			continue
		}
		mkdir -p "$d"
		if touch "$d/.entry"; then
			echo "Added $i"
		else
			echo "Failed to add $i"
		fi
		added+=("$i")
	done
	result="${added[@]}"
}

function reflow {
	for i in "$BIBBASE"/**/.entry; do
		d="${i%.entry}"
		getentry "$d" || {
			echo "${FUNCNAME[0]} getentry failed ($?): $1"
			continue
		}
		ent="$result"
		getpath "$result" || {
			echo "${FUNCNAME[0]} getentry failed ($?): $1"
			continue
		}
		newpath="$BIBBASE/$result"
		if [ ! "$d" -ef "$newpath" ]; then
			mv "$d" "$newpath"
			echo "Reflowed: $ent"
		fi
	done
}

agent="Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"

# call with args: entry path ...
# path relative to $BIBBASE
function getbib_doi {

	if [ "$#" -eq "0" ]; then
		return
	fi
	local -a args
	local -a files
	args+=("-L" "-s")
	args+=("-A" "$agent")
	args+=("-H" "Accept: application/x-bibtex")
	while
		doi=$1
		shift
		loc=$1
		shift
	do
		echo $doi $loc
		if [ ! -d $loc ]; then
			echo "Bad path: $loc Skippping."
			continue
		fi
		args+=("-o" "$loc/bib")
		files+=("$loc/bib")
		args+=("${doi/doi:/http://doi.org/}")
	done
	curl "${args[@]}" || return $?

	# Post-process
	tmpfile="$(mktemp)"
	for i in "${files[@]}"; do
		sed 's/{\\hspace{0.167em}}/ /g' "$i" > "$tmpfile"
		mv -f "$tmpfile" "$i"
	done
	rm -f "$tmpfile"
}

#need changing to new interface
function getbib_isbn {
	if [ "$#" -eq "0" ]; then
		return
	fi
	declare -a args
	args+=("-L" "-s")
	args+=("-A" "$agent")
	for i in "$@"; do
		#echo $i
		getentry "$i" || {
			echo "Bad entry: $p Skipping"
		       	continue
		}
		args+=("http://www.ottobib.com/${result/isbn:/isbn/}/bibtex")
		echo -n "Fetching $result... "
		var=$(curl "${args[@]}")
		if [ -z $var ]; then
			echo "Failed, no entry returned."
			continue
		else
			echo "Done."
		fi
		var1="@Book${var##*@Book}"
		echo ${var1%%</textarea>*} > "$i/bib"
	done

}

function getbib {
	local -a doi
	local -a isbn
	local -a arxiv
	local -a rest
	pushd $BIBBASE > /dev/null
	for i in "$@"; do
		getpath $i || {
			echo "Bad entry: $i Skipping."
			continue
		}
		p=$result
		isEntry "$BIBBASE/$p" || {
			echo "Not entry: $p Skipping."
		       	continue
		}
		[ ! -e "$BIBBASE/$p/bib" ] || {
			echo "Bib exists: $p/bib Skipping"
		       	continue
		}
		case "$i" in
		doi:*)
			doi+=("$i" "$p")
			;;
		isbn:*)
			isbn+=("$i" "$p")
			;;
		arXiv:*)
			arxiv+=("$i" "$p")
			;;
		*)
			rest+=("$i" "$p")
			;;
		esac
	done
	getbib_doi "${doi[@]}"
	#echo ===DOI===
	#echo "${doi[@]}"
	#getbib_isbn "${isbn[@]}"
	#echo ===ISBN===
	#echo "${isbn[@]}"
	#echo ===ARXIV===
	#echo "${arxiv[@]}"
	#echo ===REST===
	#echo "${rest[@]}"
	popd > /dev/null
}

function addget {
	add "$@" #returns $result array
	[ -n "${result[@]}" ] && getbib "${result[@]}"
}

function updatecache {
	bibentries=($BIBBASE/**/bib)
	for e in "${bibentries[@]%/bib}"; do
		dt="$e/.cache.bib.detex"
		if [ ! -f "$dt" ] || [ "$dt" -ot "$e/bib" ]; then
			getentry "$e"
			echo Updating detex cache for $result >&2
			detex "$e/bib" > "$dt" #Check for signal races here
		fi
	done
}

function bibgrep {
	updatecache
	mapfile -t ents < <(grep -l "$@" "$BIBBASE"/**/bib "$BIBBASE"/**/.cache.bib.detex | sed 's/bib$//;;s/\.cache\.bib\.detex$//' )
	printentry "${ents[@]}" | sort | uniq
}

function summary {
	for i in "$@"; do
		getpath $i || {
			echo "$i: Not an entry ($?)"
			continue
		}
		echo $i
		fullpath=$BIBBASE/$result
		echo "Path:" $fullpath
		if [ -f "$fullpath/bib" ]; then
			awk -F "=" '
			/author/ {print "Author:", gensub(/[[:space:]]*{(.*)}.*/, "\\1", "1", $2)}
			/title/ {print "Title:", gensub(/[[:space:]]*{(.*)}.*/, "\\1", "1", $2)}
			' "$fullpath/bib" | detex
			 awk -F '=' '/url/ { print "URL:", gensub(/.*{(.*)}.*/, "\\1", "1",  $2) }' "$fullpath/bib"
		else
			echo "No bibliographic information"
		fi
		echo -n "PDF file: "
		if [ -f "$fullpath/pdf" ]; then
			echo "yes"
		else
			echo "no"
		fi
		echo
	done
}

function list {
	for i in "$BIBBASE"/**/.entry; do
		getentry "$i" && echo $result
	done
}

function bib {
	for i in "$@"; do
		getpath $i || {
			echo "% Not an entry $i"
			continue
		}
		bibfile="$BIBBASE/$result/bib"
		[ -f "$bibfile" ] || {
			echo "% No bib file $i"
			continue
		}
		cat $bibfile
		echo
	done
}

function base {
	echo $BIBBASE
}

function open {
	for i in "$@"; do
		getpath $i
		document="$BIBBASE/$result/pdf"
		if [ -f "$document" ]; then
			xdg-open "$document" &
		else
			echo "$i: no pdf"
		fi
	done
}

function notes {
	if [ -z $EDITOR ]; then
		echo "No \$EDITOR set.  Mayabe use pen and paper?"
		exit 1
	fi
	local -a paths
	for i in "$@"; do
		getpath $i || {
			echo "Skipping bad entry $i"
			continue
		}
		paths+=("$BIBBASE/$result/notes")
	done
	$EDITOR "${paths[@]}"
}

function pdfset {
	local ent
	local pdf
	while
		ent="$1"
		shift
		pdf="$1"
		shift
	do
		getpath "$ent" || {
			echo "Not an entry $ent. Skipping."
			continue
		}
		[ ! -f "$BIBBASE/$result/pdf" ] || {
			echo "PDF already present. Skipping"
			continue
		}
		[ -f "$pdf" ] || {
			echo "$pdf not a file. Skipping."
			continue
		}
		cp "$pdf" "$BIBBASE/$result/pdf"
	done
}


function init {
	pushd $PWD > /dev/null
	cdtobaseorroot

	if [[ "$PWD" != "/" ]] || [ -f "/.bibbase" ]; then
		echo "Already a database."
	        echo "Nested databases currently not permitted."
		popd > /dev/null
		exit 1
	fi

	popd > /dev/null

	touch .bibbase
}

function addprot {
	location="$BIBBASE/$1"
	local -a addprots
	for i in "$@"; do
		if [ -d "$i" ]; then
			echo "Protocol $i already added. Skipping."
			continue
		fi
		addprots+=("$i")
	done

	mkdir "${addprots[@]}"
}

verbs=("list" "bibgrep" "summary" "bib")
verbs+=("printentry" "printpath")
verbs+=("open" "base" "notes")
verbs+=("add")
verbs+=("getbib")
verbs+=("init" "addprot")
verbs+=("reflow")
verbs+=("pdfset")
verbs+=("addget")

func="$1"
shift
if [ -z "$func" ]; then
	echo "Base directory:" "$BIBBASE"
	declare -a paths=("$BIBBASE"/**/.entry)
	echo "Number of entries:" "${#paths[*]}"
	echo "Known verbs:" "${verbs[@]}"
	exit 1
elif [[ " ${verbs[@]} " == *" ${func} "* ]]; then
	"$func" "$@"
else
	echo "Unknown verb: $func"
	exit 2
fi

