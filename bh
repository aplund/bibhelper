#!/bin/bash

shopt -s globstar

function getbase {
	declare testpath
	if [ ! -v "1" ]; then
		testpath="$PWD"
	elif [ ! -d "$1" ]; then
		testpath=$(dirname "$1")
	else
		testpath="$1"
	fi

	pushd "$testpath" > /dev/null

	while [ ! -f ".bibbase" ]; do
		if [ "$PWD" == "/" ]; then
			if [ -z "$BIBBASE" ] &&
				[ ! -f "${BIBBASE}/.bibbase"]; then
				return 1
			else
				result="$BIBBASE"
				popd > /dev/null
				return 0
			fi
		fi
		cd ..
	done

	result="$PWD"
	popd > /dev/null
}

# Setup $BIBBASE
pushd "$PWD" > /dev/null

while [ ! -f "$PWD"/.bibbase -a "$PWD" != "/" ] ; do
	cd ..
done

if [[ "$PWD" == "/" ]]; then
	if [ -f "/.bibbase" ]; then
		BIBBASE="/"   # But seriously, don't do this.
	elif [ -z "$BIBBASE" ]; then
		echo "\$BIBBASE unset and no database in path"
		exit 1
	elif [ ! -f "${BIBBASE}/.bibbase" ]; then
		echo "$BIBBASE is not a database"
		exit 1
	fi
else
	BIBBASE="$PWD"
fi

popd > /dev/null

function isEntry {
	[ -d "$1" ] && [ -f "$1/.entry" ]
}


# What about NUL?? Seems to break things in BASH.
# _ -> \x5f
# \ -> \x5c
# / -> \x2f
# % -> \x25
# A minimal set.  Printf will consume all \ and %, / disallowed by filesystem
# and we want to avoid the final \'s in the filenames

function encodestring {
	result="$1"
	result="${result//_/_x5f}"
	result="${result//\\/_x5c}"
	result="${result//\//_x2f}"
	result="${result//%/_x25}"
#	result="${result//./_x2e}"
}

function decodestring {
	result="$1"
#	result="${result//_x2e/.}"
	result="${result//_x25/%}"
	result="${result//_x2f/\/}"
	result="${result//_x5f/_}"
	result="${result//_x5c/\\}"
}

declare -a ENTRIES
function entriesorpwd {
	if [ "$#" -eq 0 ]
	then
		ENTRIES[0]=$PWD
	else
		ENTRIES=("$@")
	fi
}

function getentry {
	declare testpath=${1%.entry}
	isEntry "$testpath" || return 1
	getbase "$testpath" || return 2

	declare -a array
	
	pushd "$testpath" > /dev/null
	while [ "$PWD" != "$result" ]; do
		array=("${PWD##*/}" "${array[@]}" )
		cd ..
	done
	popd > /dev/null

	IFS="" rawstring="${array[0]}:${array[*]:1}"
	decodestring "$rawstring"
}

function printentry {
	entriesorpwd "$@"
	for i in "${ENTRIES[@]}"
	do	
		if getentry "$i"
		then
			echo "$result"	
		else
			echo "Not an entry"
		fi
	done
}

#convert string to path
#special handling of "." and ".."  They are disallowed as divisions!
#returned variables:
#	$result: path relative to $BIBBASE
function getpath {
	# String must contain a : to separate the prefix from suffix
	if [[ "$1" != *":"* ]] ; then
		return 2
	fi

	encodestring "${1#*:}"
	declare suffix="$result"
	suffix="${suffix,,}" # to lowercase
	result="${1%%:*}" # prefix
	result="${result,,}" # to lowercase

	# Root _must_ exist
	if [ ! -d "$BIBBASE/$result" ]; then
		unset result
		return 2
	fi

	declare st=0 j=0 t
	
	pushd $BIBBASE > /dev/null
	#for (( j=1, st=0 ; j <= ${#suffix} ; j=j+1 )); do
	while [ $j -le ${#suffix} ]; do
		j=$((j+1))
		app="${suffix:$st:$j-$st}"
		if [ "$app" == "." -o "$app" == ".." ]; then
			continue
		fi
		t="$result/$app"
		if [ -d "$t" ] && [ ! -f "$t"/.entry ]; then
			result=$t
			st=$j
		fi
	done
	popd > /dev/null
	result=$t
}

function printpath {
	local i
	while
		i="$1"
		shift
	do
		getpath "$i" || {
			echo "${FUNCNAME[0]} Bad string ($?): $i"
			continue
		}
		echo "$BIBBASE/$result"
	done
}

function enc {
	encodestring "$1"
	echo "$result"
}

# returns $result array of successfully added entries
function add {
	local -a addedpaths=()
	local i
	while
		i="$1"
		shift
	do
		getpath "$i" || {
			echo "${FUNCNAME[0]} Bad string ($?): $i. Skipping."
			continue
		} # getpath sets $base and $result
		d="$base/$result"
		[ -d "$d" ] && {
			echo "${FUNCNAME[0]} Entry exists: $d. Skipping."
			continue
		}
		mkdir -p "$d"
		touch "$d/.entry"
		addedpaths+=("$d")
	done
	result=("${addedpaths[@]}")
}

function reflow {
	getbase $PWD
	base="$result"

	for i in "$base"/**/.entry; do
		d="${i%.entry}"
		getentry "$d" || {
			echo "${FUNCNAME[0]} getentry failed ($?): $1"
			continue
		}
		ent="$result"
		getpath "$result" || {
			echo "${FUNCNAME[0]} getentry failed ($?): $1"
			continue
		}
		newpath="$base/$result"
		if [ ! "$d" -ef "$newpath" ]; then
			mv "$d" "$newpath"
			echo "Reflowed: $ent"
		fi
	done
}

agent="Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"

function getbib_doi {
	if [ "$#" -eq "0" ]; then
		return
	fi
	declare -a args
	args+=("-L" "-s")
	args+=("-A" "$agent")
	args+=("-H" "Accept: application/x-bibtex")
	for i in "$@"; do
		#echo $i
		getentry "$i" || {
			echo "Bad entry: $p Skipping."
		       	continue
		}
		args+=("-o" "$i/bib")
		args+=("${result/doi:/http://doi.org/}")
	done
	curl "${args[@]}" || return 1

	# Post-process
	tmpfile="$(mktemp)"
	for i in "$@"; do
		sed 's/{\\hspace{0.167em}}/ /g' "$i"/bib > "$tmpfile"
		mv -f "$tmpfile" "$i"/bib
	done
	rm -f "$tmpfile"
}

function getbib_isbn {
	if [ "$#" -eq "0" ]; then
		return
	fi
	declare -a args
	args+=("-L" "-s")
	args+=("-A" "$agent")
	for i in "$@"; do
		#echo $i
		getentry "$i" || {
			echo "Bad entry: $p Skipping"
		       	continue
		}
		args+=("http://www.ottobib.com/${result/isbn:/isbn/}/bibtex")
		echo -n "Fetching $result... "
		var=$(curl "${args[@]}")
		if [ -z $var ]; then
			echo "Failed, no entry returned."
			continue
		else
			echo "Done."
		fi
		var1="@Book${var##*@Book}"
		echo ${var1%%</textarea>*} > "$i/bib"
	done

}

function getbib {
	declare -a doi
	declare -a isbn
	declare -a arxiv
	declare -a rest
	doi=()
	entriesorpwd "$@"
	for i in "${ENTRIES[@]}"; do
		p=${i%.entry}
		[ -d "$p" ] || {
			echo "Not found: $p Skipping."
		       	continue
		}
		[ ! -e "$p/bib" ] || {
			echo "Bib exists: $p/bib Skipping"
		       	continue
		}
		getentry "$p"
		case "$result" in
		doi:*)
			doi+=("$p")
			;;
		isbn:*)
			isbn+=("$p")
			;;
		arXiv:*)
			arxiv+=("$p")
			;;
		*)
			rest+=("$p")
			;;
		esac
	done
	getbib_doi "${doi[@]}"
	#echo ===DOI===
	#echo "${doi[@]}"
	getbib_isbn "${isbn[@]}"
	#echo ===ISBN===
	#echo "${isbn[@]}"
	#echo ===ARXIV===
	#echo "${arxiv[@]}"
	#echo ===REST===
	#echo "${rest[@]}"
}

#not working?
function addget {
	add "$@" #returns $result array
	added=("${result[@]}")
	echo "${added[@]}"
	getbib "${added[@]}"
}

function bibgrep {
	ents=$(printf '%s\0' "$BIBBASE"/**/bib | xargs -0 grep -l "$@" | xargs dirname)
	printentry $ents
}

function summary {
	entriesorpwd "$@"
	for i in "${ENTRIES[@]}"; do
		getpath $i
		sed -n '
/[[:space:]]*doi[[:space:]]*=[[:space:]]*{\(.*\)}.*/{s//doi:\1/; p}
/[[:space:]]*isbn[[:space:]]*=[[:space:]]*{\(.*\)}.*/{s//isbn:\1/; p}
/[[:space:]]*title[[:space:]]*=[[:space:]]*{\(.*\)}.*/{s//\1/; p}
/[[:space:]]*author[[:space:]]*=[[:space:]]*{\(.*\)}.*/{s//\1/; p}' "$base/$result"/bib
		echo
	done
}

function list {
	getbase
	for i in "${result}"/**/.entry; do
		getentry "$i" && echo $result
	done
}

function base {
	getbase $PWD && echo $result
}

verbs=("list" "bibgrep")
#verbs+=("summary" "bibgrep")
#verbs+=("add" "addget" "getbib")
#verbs+=("printentry" "printpath")
#verbs+=("reflow" "base")

func="$1"
shift
if [ -z "$func" ]; then
	echo "Base directory: " "$BIBBASE"
	declare -a paths=("$BIBBASE"/**/.entry)
	echo "Number of entries:" "${#paths[*]}"
	echo "Known verbs:" "${verbs[@]}"
	exit 1
elif [[ "${verbs[*]}" == *"${func}"* ]]; then
	"$func" "$@"
else
	echo "Unknown verb: $func"
	exit 2
fi

